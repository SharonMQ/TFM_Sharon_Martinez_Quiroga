---
title: "Trabajo de Fin de Máster: Workflow 1 con iClusterBayes como método de integración de datos multiómicos"
date: "1/5/2021"
output: pdf_document
bibliography: Workflow1.bib
nocite: '@curatedTCGAData, @mancuratedTCGAData, @paqcuratedTCGAData, @readr @LaTexMathematics, @RstudioUnusedReferences, @citarbib' 
---

**_Máster en Bioinformática y Bioestadística_** 

**Área del trabajo:_2_**

**Título del Trabajo: _Detección de biomarcadores de prognosis en Colon adenocarcinoma mediante la integración de datos ómicos con varios métodos disponibles_**

**Nombre del autor/a:_Sharon Martínez Quiroga_**

**Nombre del consultor/a:_Jaume Sastre Tomàs_**

**Nombre del PRA:_Marc Maceira Duch_**




## Indice:

1. __Preparación del entorno de trabajo.__
  * 1.1. _Preparación del entorno._
  * 1.2. _Carga de paquetes a utilizar._
2. __Descarga de datos.__
3. __Selección y filtrado de datos__
  * 3.1. _Selección de muestras patológicas._
  * 3.2. _Selección de muestras que tengan datos pada las tres ómicas a integrar._
  * 3.3. _Filtrado de muestras con x% de missing values en todas las ómicas._
  * 3.4. _Filtrado de variables con un x% de missing values._
4. __Imputación de missing values.__
5. __Transformación de datos.__
6. __Control de calidad.__
7. __Normalización de datos.__
8. __Control de calidad.__
9. __Integración de datos.__
10. __Visualización de resultados.__
11. __Integración de redes.__
12. __Análisis de prognosis.__
113. __Modelo de Prognosis.__
11. __Evaluación del modelo de prognosis.__

## Preparación del entorno de trabajo:

### 1.1. Preparación del entorno:

Lo primero que hacemos es definir en el chunk el atributo cache=TRUE, para que R guarde los resultados de los chunks y solo repita la ejecución de un chunk, y de los otros chunks que se vean afectados por dicho cambio cuando se cambie el código en el chunk.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NULL, cache = TRUE)
```

Ahora definimos nuestro directorio:
```{r}
setwd("/media/home/ESD-USB/UOC/6to cuatrimestre/TFM/Workflows/Wirkflow iClusterBayes")
```

### 1.2. Carga de paquetes a utilizar.

Ahora vamos a cargar los paquetes que vamos a utilizar y que explicaremos según se vayan requiriendo:

```{r message=FALSE, warning=FALSE}
library(curatedTCGAData)
library(readr)

```

## 2.Descarga de datos.

Para saber que archivos que queremos descargar será necesario ver que archivos hay disponibles para Adenocarcinoma de colon (*COAD*). Esto se realizará con la función `curatedTCGAData` del paquete con el mismo nombre$^{1,2,3}$. Para ello se definirán los atributos:

* _`diseaseCode`_: código de la enfermedad de estudio, en este caso COAD.
* _`assays`_: tipos de datos de los que se quiere información. Se indicará "*" para ver todos los datos disponibles.
* _`dry.run`_: Se indicará TRUE porque solo queremos visualizar un resumen de los datos. Si se indicara FALSE se descargarían los paquetes indicados.$^{1,2}$

```{r}
curatedTCGAData(diseaseCode = "COAD", assays = "*", dry.run = TRUE)
```

Ahora vamos a descargar los datos con la misma función, pero indicando los siguientes atributos:

* _`diseaseCode`_: COAD.
* _`assays`_: solo indicaremos GISTIC_AllByGene porque el paquete descarga muy pocos datos de las demás ómicas que queremos.
* _`dry.run`_: Se indicará TRUE porque solo queremos visualizar un resumen de los datos. Si se indicara FALSE se descargarían los paquetes indicados.$^{1,2}$

Solo se descargargarán los archivos "GISTIC_AllByGene", "Methylation_methyl450", "miRNASeqGene" porque los archivo de "RNASeqGene" y "RNASeq2GeneNorm" no contienen los datos de todas las muestras disponibles en la web de Firehouse, por lo que los datos de RNAseq se descargarán manualmente. 

```{r message=FALSE, warning=FALSE}
datos_COAD<-curatedTCGAData::curatedTCGAData(diseaseCode = "COAD", 
assays = c("GISTIC_AllByGene", "Methylation_methyl450", "miRNASeqGene", "RPPAArray"),
dry.run = FALSE)
```

Los datos que se van a utilizar y que se han descargado son:

*

Se observó que hay menos datos de mRNAseq en disponibles en el paquete`curatedTCGAData` que en la web de Firehose, por tanto, se descargó manualmente el archivo y se guardó en el directorio de este papeline. Posteriormente se cargó usando la función `read_delim` del paquete `readr`. Como se encuentra en el mismo directorio del papeline no fue necesario indicar la ruta. Los atributos indicados fueron:

*`file`: nombre del documento o ruta. 
*`delim`: tipo de separación entre los valores, en este caso, tab `\t`

```{r message=FALSE, warning=FALSE}
datos_mRnaseq<- 
  read_delim("COAD.rnaseqv2__illuminahiseq_rnaseqv2__unc_edu__Level_3__RSEM_genes__data.data.txt", 
    "\t")
datos_mRnaseq[1:5,1:5]
```

Como vemos hay varias columnas por cada muestra, lo que hace esencial que procesemos el data frame, para ello usaremos la función `select` del paquete `dplyr` que permite seleccionar las columnas que terminen en determinados caracteres mediante el atributo `ends_with` o bien no terminen en dichos caracteres si le añadimos un operador `!` delante.

https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/select
```{r}
datos_mRnaseq<-dplyr::select(datos_mRnaseq, !ends_with("_1"))
datos_mRnaseq<-dplyr::select(datos_mRnaseq, !ends_with("_2"))
datos_mRnaseq[1:5, 1:5]
```
..... Ahora será necesario eliminar la fila 1

```{r}
datos_mRnaseq<-datos_mRnaseq[2:20532,1:329]
datos_mRnaseq[1:5, 1:5]
```

En este archivo vienen ya anotados los genes de los que se conoce el gen_ID como vamos a ver:

```{r}
datos_mRnaseq[28:32, 1:5]
```

A continuación nos quedaremos solo con la expresión de aquellos genes que si tengan anotado el gen ID, para ello usaremos la función 

```{r}
names<-as.vector(as.matrix(datos_mRnaseq[,1]))
head(names)
```
https://r4ds.had.co.nz/strings.html#detect-matches
https://www.rdocumentation.org/packages/stringr/versions/0.6.2/topics/fixed
https://stackoverflow.com/questions/31585111/regular-expression-error-when-using-stringr-r-package-to-search-for-curly-brac


```{r}
names<-stringr::str_detect(names, stringr::fixed("?"))
```

```{r}
names[1:5]
names[28:32]
table(factor(names))
```

Vemos que se ha reconocido correctamente los genes sin gene_ID identificado, y ahora vamos a quedarnos con los 

```{r}
datos_mRnaseq_pros<-data.frame()
for (i in 1:length(names)){
  if (names[i]==FALSE){
    if(i==1){
      datos_mRnaseq_pros<-datos_mRnaseq[i,]
    }
    if(i>1){
      datos_mRnaseq_pros<-rbind(datos_mRnaseq_pros, datos_mRnaseq[i,])
    }
  }
}
datos_mRnaseq_pros[1:5, 1:5]
```

```{r}
nrow(datos_mRnaseq_pros)
```

## Bibliografía:

