---
title: "Trabajo de Fin de Máster: Workflow 1 con iClusterBayes como método de integración de datos multiómicos"
date: "1/5/2021"
output: pdf_document
bibliography: Workflow1.bib
csl: springer-vancouver-brackets.csl
---

**_Máster en Bioinformática y Bioestadística_** 

**Área del trabajo:_2_**

**Título del Trabajo: _Detección de biomarcadores de prognosis en Colon adenocarcinoma mediante la integración de datos ómicos con varios métodos disponibles_**

**Nombre del autor/a:_Sharon Martínez Quiroga_**

**Nombre del consultor/a:_Jaume Sastre Tomàs_**

**Nombre del PRA:_Marc Maceira Duch_**




## Indice:

1. __Preparación del entorno de trabajo.__
  * 1.1. _Preparación del entorno._
  * 1.2. _Carga de paquetes a utilizar._
2. __Descarga de datos.__
3. __Selección de muestras__
  * 3.1. _Selección de muestras patológicas._
  * 3.2. _Selección de muestras que tengan datos pada las tres ómicas a integrar._
  * 3.3. _Selección de variables clínicas para el análisis de supervivencia._
4. __Filtrado de muestras__
  * 4.1. _Filtrado de muestras con determinado porcentaje de missing values en todas las ómicas._
  * 4.2. _Filtrado de variables con determinado porcentaje de missing values en todas las ómicas._
5. __Imputación de missing values.__
6. __Transformación de datos.__
7. __Control de calidad.__
8. __Normalización de datos.__
9. __Control de calidad.__
10. __Integración de datos.__
11. __Visualización de resultados.__
12. __Integración de redes.__
13. __Análisis de prognosis.__
14. __Modelo de Prognosis.__
15. __Evaluación del modelo de prognosis.__

## Preparación del entorno de trabajo:

### 1.1. Preparación del entorno:

Lo primero que hacemos es definir en el chunk el atributo cache=TRUE, para que R guarde los resultados de los chunks y solo repita la ejecución de un chunk, y de los otros chunks que se vean afectados por dicho cambio cuando se cambie el código en el chunk.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NULL, cache = TRUE)
```

Ahora definimos nuestro directorio:
```{r}
setwd("/media/home/ESD-USB/UOC/6to cuatrimestre/TFM/Workflows/Workflow iClusterBayes")
```

### 1.2. Carga de paquetes a utilizar.

Ahora vamos a cargar los paquetes que vamos a utilizar y que explicaremos según se vayan requiriendo:

```{r message=FALSE, warning=FALSE}
library(curatedTCGAData)
library(readr)
library(TCGAutils)
library(MultiAssayExperiment)
library(dplyr)
```

## 2.Descarga de datos.

### Descarga de datos de CNA y Metilación de DNA:

Para saber que archivos que queremos descargar será necesario ver que archivos hay disponibles para Adenocarcinoma de colon (*COAD*). Esto se realizará con la función `curatedTCGAData` del paquete con el mismo nombre [@curatedTCGAData; @mancuratedTCGAData; @paqcuratedTCGAData]. Para ello se definirán los atributos:

* _`diseaseCode`_: código de la enfermedad de estudio, en este caso COAD.
* _`assays`_: tipos de datos de los que se quiere información. Se indicará "*" para ver todos los datos disponibles.
* _`dry.run`_: Se indicará TRUE porque solo queremos visualizar un resumen de los datos. Si se indicara FALSE se descargarían los paquetes indicados.$^{1,2}$

```{r message=FALSE, warning=FALSE}
curatedTCGAData(diseaseCode = "COAD", assays = "*", dry.run = TRUE)
```

Ahora vamos a descargar los datos con la misma función, pero indicando los siguientes atributos:

* _`diseaseCode`_: COAD.
* _`assays`_: solo indicaremos GISTIC_AllByGene porque el paquete descarga muy pocos datos de las demás ómicas que queremos.
* _`dry.run`_: Se indicará TRUE porque solo queremos visualizar un resumen de los datos. Si se indicara FALSE se descargarían los paquetes indicados.$^{1,2}$

Solo se descargargarán los archivos "GISTIC_AllByGene", "Methylation_methyl450", "miRNASeqGene" porque los archivo de "RNASeqGene" y "RNASeq2GeneNorm" no contienen los datos de todas las muestras disponibles en la web de Firehouse, por lo que los datos de RNAseq se descargarán manualmente. 

```{r message=FALSE, warning=FALSE}
datos_COAD<-curatedTCGAData::curatedTCGAData(diseaseCode = "COAD", 
assays = c("GISTIC_AllByGene", "Methylation_methyl450"),
dry.run = FALSE)
```

Los datos que se van a utilizar y que se han descargado son:

* GISTIC_AllByGene: Esta base de datos contiene los CNA por gen en scores. Para obtener los scores, GISTIC primero calcula las unidades de CNA-2 por CNA medido(marker level), 2 porque el ser humano tiene mínimo dos copias de cada gen o región, una por alelo o cromosoma homólogo. Como tenemos valores de CNA, el marker level nunca podrá tener valor 0, es decir, siempre habrá amplificación o deleción de copias. Los números positivos indican amplificación y los negativos deleción. A partir de estos valores GISTIC obtiene los scores que miden el nivel de CNAs por gen (gene level). El método que usa para obtener los scores se denomina método extremo, porque el score es el mayor marker level de cada gen para cada muestra, es decir, elige de entre las unidades de CNA-2, calculadas antes, el CNA que de entre todos los CNA presentes en dicho gen, tenga mayor amplificación, o bien, el menor valor de deleción. 

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5302158/

* Methylation_methyl450: Contiene los row counts para cada probe del array 

Estos datos se han descargado en un objeto MultiAssayExperiment usado por algunas herramientas de integración como por ejemplo MOFA. Estos objetos permiten almacenar varios experimentos con distinto número de filas(variables). Su estructura es la siguiente:

* `ExperimentList`: Es una lista que contiene los distintos experimentos(Assays) que se han descargado. Los datos de los experimentos, guardados en la lista, están almacenados en un data frames por experimento, donde las columnas son las muestras u observaciones, y las filas las variables medidas para cada expreimento. Em esta ÈxperimentList` se encuentra:

```{r}
datos_COAD@ExperimentList
```

* `colData`: contiene los datos clínicos de cada muestra, es un data frame con una fila por muestra y una columna por variable cínica. En este caso:

```{r}
datos_COAD@colData[1:5,1:5]
```

* `sampleMap`: Contiene una tabla con los códigos de referencia de las muestras que hay por cada experimento.

```{r}
 datos_COAD@sampleMap
```

https://bioconductor.org/packages/release/bioc/vignettes/MultiAssayExperiment/inst/doc/MultiAssayExperiment.html#a-brief-description
http://bioconductor.org/packages/release/bioc/vignettes/MOFA/inst/doc/MOFA_example_scMT.html

En iClusterBayes se usan data frames por lo que más adelante será necesario extraer los datos del objeto MultyAssayExperiment.

https://bioconductor.org/packages/release/bioc/vignettes/iClusterPlus/inst/doc/iManual.pdf
### Descarga de mRNAseq:

Se observó que hay menos datos de mRNAseq en disponibles en el paquete `curatedTCGAData` que en la web de Firehose, por tanto, se descargó manualmente el archivo y se guardó en el directorio de este papeline. Posteriormente se cargó usando la función `read_delim` del paquete `readr`. Como se encuentra en el mismo directorio del papeline no fue necesario indicar la ruta. Los atributos indicados fueron:

* `file`: nombre del documento o ruta. 
* `delim`: tipo de separación entre los valores, en este caso, tab `\t`

```{r message=FALSE, warning=FALSE}
datos_mRnaseq<- 
  read_delim("COAD.rnaseqv2__illuminahiseq_rnaseqv2__unc_edu__Level_3__RSEM_genes__data.data.txt", 
    "\t")
datos_mRnaseq[1:5,1:5]
```

Como se puede ver hay varias variables por cada muestra, lo que hace esencial que se procese el data frame para quedarse solo con la columna de raw_counts de cada muestra y la columna "Hybridization REF" con las anotaciones de los genes_ID. Para elegir solo las columnas que queremos se usará la función `select` del paquete `dplyr` que permite seleccionar las columnas que terminen en determinados caracteres mediante el atributo `ends_with` o bien, seleccionar las que no terminen en determinados caracteres si se le añade un operador `!` delante de `ends_with`. Se seleccionaran aquellas columnas que no terminen en "_1" y "_2".

https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/select

```{r}
datos_mRnaseq<-dplyr::select(datos_mRnaseq, !ends_with("_1"))
datos_mRnaseq<-dplyr::select(datos_mRnaseq, !ends_with("_2"))
datos_mRnaseq[1:5, 1:5]
```
Una vez eliminadas las columnas que no se van a usar, será necesario eliminar la fila 1 para que al usar los datos dicha fila no genere errores.

```{r}
datos_mRnaseq<-datos_mRnaseq[2:20532,1:329]
datos_mRnaseq[1:5, 1:5]
```

En este archivo vienen ya mapeados los transcritos secuenciados con RNAseq, por lo que se tiene los row counts para cada gen. Además, en la primera columna está anotado el "Gene Symbol" o Símbolo oficial del gen y el "gen_ID" o identificador del gen de Entrez Gene, separados por el caracter "|".

https://bioconductor.org/packages/release/data/annotation/manuals/org.Hs.eg.db/man/org.Hs.eg.db.pdf

```{r}
datos_mRnaseq[28:32, 1:5]
```

Se ha observado en búsquedas en Gene de NCBI que hay genes en los que no está anotado el Gene Symbol, pero que desde que se hizo la versión de este archivo ya se han anotado, o bien otros han cambiado de Gene Symbol. Por ello, cuando se haya realizado la integración y se haya obtenido los genes que pueden ser posibles biomarcadores, se les eliminará los Gene Symbol y se volverá a realizar la anotación de los mismos a partir de los códigos Entrez_ID. Además, se ha observado que algunos códigos Entrez_ID están descatalogados y se les ha asignado un nuevo código Entrez_ID que habrá que anotar manualmente cada vez que en la anotación ocurra un error. Por esta razón se dejará este paso para más adelante, ya que solo se anotarán los genes diferencialmente expresados que sean importantes tras la integración.

A continuación, se convertirá los gene_ID en los nombres de las filas y eliminaremos la primera columna de datos_mRnaseq, para que no de problemas en el resto de pasos de este análisis, ya que se tomaría la primera columna como una muestra con datos de counts. 

Para guardar los datos de gene_ID como vector primero es necesario convertir la
columna extraida del data frame en una matriz.
```{r}
row_n<-as.vector(as.matrix(datos_mRnaseq[, 1]))
head(row_n)
```

Ahora se guarda datos_mRnaseq sin la primera columna.
```{r}
datos_mRnaseq<-datos_mRnaseq[,2:329]
datos_mRnaseq[1:5,1:2]
```

Finalmente, se da nombre a las filas, para ello primero se tiene que hacer es transformar datos_mRnaseq en un data frame normal, ya que de firehose se descarga en formato tibble, que es un tipo especial de data frame usado en ciencia de datos que no acepta que las filas tengan nombre, y que no es el usado por iClusterBayes.

https://tibble.tidyverse.org/
```{r}
datos_mRnaseq<-as.data.frame(datos_mRnaseq)
rownames(datos_mRnaseq)<-row_n
datos_mRnaseq[1:5,1:2]
```

Para iClusterBayes será necesario trasponer este data frame, para que las muestras sean las filas y los genes las columnas, pero se realizará después de la normalización de datos.

https://bioconductor.org/packages/release/bioc/vignettes/iClusterPlus/inst/doc/iManual.pdf

## 3.Selección de muestras

### 3.1.Selección de muestras patológicas.

Para seleccionar las muestras patológicas vamos a usar dos métodos distintos según si los datos están en el objeto MultiAssayExperiment o en el data frame.

* *Selección de muestras patológicas guardadas en el objeto MultiAssayExperiment(datos_COAD)*: 

Se utilizará el paquete `TCGAutils` para hacer la selección. Lo primero que se realizará será ver los tipos de muestras que hay disponibles en TCGA y su código correspondiente dentro de los códigos de referencia. Para ello se descargará el data frame "sampleTypes" que contiene esta información disponible en el paquete. 

https://bioconductor.org/packages/release/bioc/vignettes/TCGAutils/inst/doc/TCGAutils.html#mergecoldata-expanding-the-coldata-of-a-multiassayexperiment

```{r}
data("sampleTypes")
sampleTypes
```

Ahora se verá los tipos de muestras que hay en el objeto "datos_COAD" por experimento, se usará la función `sampleTables` del mismo paquete.

```{r}
sampleTables(datos_COAD)
```
Como se ve la mayor parte de las muestras tiene el código "01" por lo que pertenecen al Tumor Primario. También hay alguna muestra de tumor recidivante "02" y de metastasico "06", pero no se van a incluir en el análisis porque, por un lado, no hay un número de muestras significativo de estos tipos, así que incluirlas solo añadiría impresición al análisis. Y por otro lado, estos tipos de muestras no aparecen en todas las ómicas.

Además, como buscamos marcadores de prognosis descartaremos las muestras de tejido normal adyacente al tumor, "11".

Para seleccionar las muestras "01" se usará la función `splitAssays` del paquete `TCGAutils`.

```{r message=FALSE, warning=FALSE}
datos_COAD_se<- splitAssays(datos_COAD, "01")
```

Se comprueba que se han guardado solo los "01":
```{r}
sampleTables(datos_COAD_se)
```
* *Selección de muestras patológicas guardadas en el data frame(datos_mRNAseq)*: 

Para obtener las muestras patológicas lo primero que se debe hacer es guardar en un vector "names" los códigos de referencia, y posteriormente extraer de cada código el fragmento que nos indica el tipo de muestra. Para ello se usa la función `str_sub` del paquete `stringr`, y se indica que los caracteres que nos interesan empiezan en la posición 14 y terminan en la 15, por tanto, son los dos caracteres de la región "Sample" del código de referencia. 

```{r}
names<-as.vector(colnames(datos_mRnaseq))
names<-stringr::str_sub(names, start =14 , end = 15)
names[7:10]
```

Se observa, en las muestras de las posiciones 7-10 del vector, que hemos extraido las regiones de interes, se eligieron estas posiciones porque se ven dos posibles códigos.

```{r}
datos_mRnaseq[1:5, 7:10]
```

Se comprueba que los códigos extraidos son los que se desea. Ver _Anexo: Código TCGA_ de la memoria. 

A continuación creamos un vector "TP" en el que se guarda TRUE cada vez que en "names" aparece un código "01" o Tumor Primario.
```{r}
TP<-as.vector(names=="01")
TP[7:11]
table(TP)
```

Se observa que la mayoría de los datos son de Tumor Primario.

A continuación, se crea una función `selec_col` en la que se recorre la posición "i" de cada elemento del vector "boolean_vector". En dicho vector aparece TRUE cada vez que en esa posición hay una de las muestras que queremos. Todas las muestras se han extraido del data frame "data" en ese orden. Finalmente, cada vez que hay un TRUE se añadirá la columna del data frame original "data" que esté en la misma posición a un nuevo data frame, obteniendo como resultado de la función un data frame con las muestras deseadas.

```{r}
selec_col<-function(data, boolean_vector){
  db<-data.frame()
  p<-0
  for (i in 1:length(boolean_vector)){
    if (boolean_vector[i]==TRUE){
      if(i==1){
        db<-data[,i]
      }
      if(i>1){
        if(p==1){
          db<-cbind(db, data[,i])
        }
        if(p==0){
          db<-data[,i]
          p<-1
        }
      }
    }
  }
  return(db)
}
```

Se usa la función `selec_col` definiendo:

* `data`: datos_mRnaseq.
* `boolean_vector`: TP.

Y se comprueba los resultados:
```{r}
datos_mRnaseq_se<-as.data.frame(selec_col(datos_mRnaseq, TP))
datos_mRnaseq_se[1:5, 7:11]
```
Se comprueba que los datos coinciden con los de las muestras con "01" en la cuarta región del código.
```{r}
datos_mRnaseq[1:5, 7:11]
```

Ahora se seleccionarán los nombres de las columnas y se renombrarán las columnas y filas. Se crea una función igual que la anterior, llamada `selec_col_n`, pero que en vez de introducirle un data frame con las columnas a seleccionar, se le introduce un vector con los elementos a guardar `col_n_data`. Se guardarán los elementos de `col_n_data` que aparezcan en las posiciones TRUE del `boolean_vector`. El resultado será un vector con los nombres de las muestras con tumor primario seleccionadas.

```{r}
selec_col_n<-function(col_n_data, boolean_vector){
  v<-vector()
  p<-0
  for (i in 1:length(boolean_vector)){
    if (boolean_vector[i]==TRUE){
      if(i==1){
        v<-col_n_data[i]
      }
      if(i>1){
        if(p==1){
          v<-c(v, col_n_data[i])
        }
        if(p==0){
          v<-col_n_data[i]
          p<-1
        }
      }
    }
  }
  return(v)
}
```
Se usa la función `selec_col` definiendo:

* `col_n_data`:colnames(datos_mRnaseq) .
* `boolean_vector`: TP.

```{r}
col_n<-selec_col_n(as.vector(colnames(datos_mRnaseq)),TP )
col_n[7:11]
```

Y se comprueba los resultados viendo que se han eliminado los "11":
```{r}
colnames(datos_mRnaseq[7:12])
```

Finalmente damos nombre a las filas y columnas:

```{r}
colnames(datos_mRnaseq_se)<-col_n
rownames(datos_mRnaseq_se)<-rownames(datos_mRnaseq)
datos_mRnaseq_se[1:5,6:9]
```


### 3.2. Selección de muestras que tengan datos para las tres ómicas a integrar.

* *Muestras con datos de CNA y Metilación de DNA:*
Ahora se seleccionarán aquellas observaciones que tengan datos en todas las ómicas. Lo primero es ver las observaciones que tienen datos de CNA y Metilación, ya que se encuentran en un objeto MultiAssayExperiment, y existe una función `MatchedAssayExperiment` del paquete `MultiAssayExperiment` que selecciona las observaciones presentes en todos los assays del objeto. 

```{r message=FALSE, warning=FALSE}
datos_COAD_se<-MatchedAssayExperiment(datos_COAD_se)
datos_COAD_se@ExperimentList@listData
```

Como se observa, hay el mismo número de columnas en ambos assays, en CNA = `r ncol(datos_COAD_se@ExperimentList@listData$'01_COAD_GISTIC_AllByGene-20160128')` y en Met=`r `ncol(datos_COAD_se@ExperimentList@listData$'01_COAD_Methylation_methyl450-20160128')`

Más adelante se utilizarán estos datos como data frame, por lo que se va a proceder a guardar los datos del objeto MultiAssayExperiment en un directorio llamado "datos". Para ello se usará la función `exportClass` del paquete `MultiAssayExperiment`.

https://bioconductor.org/packages/devel/bioc/vignettes/MultiAssayExperiment/inst/doc/QuickStartMultiAssay.html

```{r}
dir.create("Datos")
exportClass(datos_COAD_se, dir = "Datos", fmt = "csv", ext = ".csv")
```

Ahora se cargarán los data frames guardados para poder usarlos en los pasos siguientes.

Lo primero que se hará será cargar los datos de CNA y de Metilación siguiendo el mismo proceso. Para ello primero se cargará el archivo.csv con la función `read_csv` del paquete `readr`. Como se cargan en formato tribble se convertirán a data frame con `as.data.frame`. La primera columna son los nombres de las filas, genes, por lo que se da los valores de la primera columna a las filas con la función `rownames`, y a continuación se elimina la primera columna.
```{r message=FALSE, warning=FALSE}
datos_CNA<-as.data.frame(read_csv("Datos/datos_COAD_se_01_COAD_GISTIC_AllByGene-20160128.csv"))
rownames(datos_CNA)<-datos_CNA$X1
datos_CNA<-datos_CNA[, -1]
datos_CNA[1:5, 1:2]
```

A continuación se acortarán los nombres de las muestras, dejando solo la parte del código común a todas las muestras de un mismo participante, inclusive se eliminará el 01 de tumor primario. Esto se hará con la función `str_sub` del paquete `stringr`.

```{r message=FALSE, warning=FALSE}
temp<-colnames(datos_CNA)
colnames(datos_CNA)<-stringr::str_sub(temp, start=1, end=12)
datos_CNA[1:5, 1:2]
```

Se comprueba que los códigos y sus datos coinciden, y por tanto se ha realizado correctamente el cambio de nombre de las columnas.

Se repite todo el proceso con los datos de metilación:
```{r message=FALSE, warning=FALSE}
datos_Met<-as.data.frame(read_csv("Datos/datos_COAD_se_01_COAD_Methylation_methyl450-20160128.csv"))
rownames(datos_Met)<-datos_Met$X1
datos_Met<-datos_Met[, -1]
datos_Met[1:5, 1:2]
```

Se renombra las muestras:
```{r message=FALSE, warning=FALSE}
temp<-colnames(datos_Met)
colnames(datos_Met)<-stringr::str_sub(temp, start=1, end=12)
datos_Met[1:5, 1:2]
```

Finalmente se cargan los datos clínicos. Se define los nombres de las filas como los códigos de referencia por paciente, patientID, que es la segunda columna que aparece, y que es idéntica a la primera. Por esta razón, despues de dar nombre a las filas se eliminan las dos primeras columnas.

```{r message=FALSE, warning=FALSE}
datos_clinicos<-as.data.frame(read_csv("Datos/datos_COAD_se_colData.csv"))
rownames(datos_clinicos)<-datos_clinicos$patientID
datos_clinicos<-datos_clinicos[, 3:2616]
datos_clinicos[1:5, 1:5]
```

* *Muestras con datos de CNA, Metilación de DNA y mRNA:*

__A continuación, se selecciona los datos de mRNAseq que haya para estas muestras con CNA y Metilación, y al final se eliminará las muestras de CNA y Met para las que no haya datos de mRNAseq.__

__La primera parte es seleccionar las muestras de mRNAseq que tienen datos de CNA y de Metilación__, para ello se va a juntar en el mismo vector los códigos de las muestras de mRNA y los de las muestras en CNA, posteriormente se factorizará el vector, y se elaborará una tabla con la frecuencia de los niveles(muestras). Se seleccionará aquellos niveles que tengan una frecuencia de 2 (1 por mRNAseq y 1 por CNA). No se une también las muestras de Met porque coinciden con las de CNA, añadirlos sería un paso innecesario.

Para hacer este proceso es necesario que coincidan los nombres de las muestras, así que se debe acortar los códigos de referencia de los datos de mRNAseq, al igual que se hizo con los demás  sets de datos. Primero se mostrará el data frame inicial para poder posteriormente comprobar que el cambio se realizó sin generar errores.
```{r}
datos_mRnaseq_se[1:5,1:3]
```

A continuación renombramos las muestras y comprobamos, comparando con el resultado anterior, que se han renombrado las muestras sin generar errores en la correspondencia datos y código.
```{r}
temp<-colnames(datos_mRnaseq_se)
colnames(datos_mRnaseq_se)<-stringr::str_sub(temp, start=1, end=12)
datos_mRnaseq_se[1:5,1:3]
```

PAra ver que muestras están en las tres ómicas se guarda en el mismo vector el nombre de las muestras de CNA y Met, y los nombres de mRNAseq.

```{r}
muestras<-c(colnames(datos_CNA), colnames(datos_mRnaseq_se))
length(muestras)==length(colnames(datos_CNA))+length(colnames(datos_mRnaseq_se))
```

Observamos que se han guardado todos los códigos de las ómicas a estudiar(recordemos que se omitió Met para evitar redundancia), ya que el vector de los códigos conjuntos es igual a la suma de los códigos de cada ómica. 
```{r}
muestras_se<-as.data.frame(table(factor(muestras)))
head(muestras_se)
```
A continuación se selecciona aquellas muestras que aparezcan 2 veces, y como hay una por fila del data frame, contamos cuantas muestras están en datos CNA y mRNAseq mediante `nrow`. 
```{r}
muestras_se<-muestras_se[muestras_se$Freq==2,]
nrow(muestras_se)
head(muestras_se)
```
A continuación se define una función, `selec_omicas` que recorre cada código de cada muestra de la base de datos original, datos_mRnaseq_se, y los compara con cada código de aquellas muestras que se quiere seleccionar, que son las de frecuencia 2. Por cada muestra de la base de datos original se guardará un boolean en un vector que se ha denominado `TP`. El boolean sera TRUE si la muestra de esa posición coincide con alguna de las muestras deseadas, y será FALSE si no hay ninguna coincidencia.

```{r}

selec_omicas<-function(datos, datos_selec){
  boolean_vector<-vector()
  for (i in 1:length(datos)){
    t<-0
    for(j in 1:length(datos_selec)){
      if (datos[i]==datos_selec[j]){
        t<-1
      }
    }
    if (t==1){
       boolean_vector<-c(boolean_vector, TRUE)
    }
    if (t==0){
       boolean_vector<-c(boolean_vector, FALSE)
    }
  }
  return(boolean_vector)
}

```

A continuación se llama a la función definiendo:

*`data`: códigos de las muestras en datos_mRnaseq_se, es decir, nombre de las columnas.

*`datos_selec`: códigos de las muestras presentes en datos_mRnaseq_se y datos_CNA.

```{r}
names<-colnames(datos_mRnaseq_se)
temp<-as.vector(muestras_se$Var1)
muestras_mRNA<-selec_omicas(names, temp)
head(muestras_mRNA)
```
Se genera un vector de booleans que indica en cada posición si la correspondiente columna en datos_mRnaseq_se está también presente en datos_CNA. A continuación, se llama a las funciones `selec_col` y `selec_col_n` para seleccionar las columnas de datos_mRnaseq_se que tengan un TRUE en el vector de booleans generado con la función `selec_omicas` guardado bajo el nombre "muestras mRNA". 

```{r}
datos_mRnaseq_def<-as.data.frame(selec_col(datos_mRnaseq_se, muestras_mRNA))
colnames(datos_mRnaseq_def)<-selec_col_n(colnames(datos_mRnaseq_se), muestras_mRNA)
row.names(datos_mRnaseq_def)<-row.names(datos_mRnaseq_se)
ncol(datos_mRnaseq_def)==nrow(muestras_se)
```

Se ve el data frame de datos mRNA:
```{r}
datos_mRnaseq_def[1:5,1:2]
```

Se observa que el resultado final es un data frame con datos de mRNAseq con el mismo número de columnas, muestras, que el número de filas, muestras, cuyo código estaba en datos_mRNAseq_se y en datos_CNA.

__La segunda parte de este proceso consiste en eliminar de los data frames de CNA y Met las muestras que no tengan datos de mRNA.__ Para ello primero obtendremos, con la función `selec_omicas`, un vector de booleans que indique que muestras del data frame "datos_CNA" o bien "datos_Met", también están en el data frame "datos_mRnaseq_def". Habrá un TRUE en cada posición de "datos_CNA" o "datos_Met" en la que ocurra una coincidencia con alguna muestra de datos_mRNAseq_def. Después, con la función `selec_col` se guardará aquellas columnas de "datos_CNA" o "datos_Met" de muestras que tengan un TRUE en el vector de booleans. Finalmente dará el nombre de cada muestra a cada columna del nuevo data frame con la función `selec_col_n`. 

  * Para CNA:
```{r}
names<-colnames(datos_CNA)
temp<-colnames(datos_mRnaseq_def)
muestras_CNA<-selec_omicas(names, temp)
head(muestras_CNA)
```

```{r}
datos_CNA_def<-as.data.frame(selec_col(datos_CNA, muestras_CNA))
colnames(datos_CNA_def)<-selec_col_n(colnames(datos_CNA), muestras_CNA)
row.names(datos_CNA_def)<-row.names(datos_CNA)
datos_CNA_def[1:5,1:2]
```

* Para Metilación:

```{r}
names<-colnames(datos_Met)
temp<-colnames(datos_mRnaseq_def)
muestras_Met<-selec_omicas(names, temp)
head(muestras_Met)
```

```{r}
datos_Met_def<-as.data.frame(selec_col(datos_Met, muestras_Met))
colnames(datos_Met_def)<-selec_col_n(colnames(datos_Met), muestras_Met)
row.names(datos_Met_def)<-row.names(datos_Met)
datos_Met_def[1:5,1:2]
```


Finalmente se hace con los datos clínicos:

```{r}
datos_clinicos<-t(datos_clinicos)
names<-colnames(datos_clinicos)
temp<-colnames(datos_mRnaseq_def)
muestras_clinicas<-selec_omicas(names, temp)
head(muestras_clinicas)
```

```{r}
datos_clinicos_def<-as.data.frame(selec_col(datos_clinicos, muestras_clinicas))
colnames(datos_clinicos_def)<-selec_col_n(colnames(datos_clinicos), muestras_clinicas)
row.names(datos_clinicos_def)<-row.names(datos_clinicos)
datos_clinicos_def<-as.data.frame(t(datos_clinicos_def))
datos_clinicos_def[1:5,1:5]
```
```{r}
nrow(datos_clinicos_def)
```

Se observa que se han seleccionado las muestras correctas ya que se tiene el mismo número de muestras que en las ómicas.

### 3.3. _Selección de variables clínicas para el análisis de supervivencia._

Como hay tantas variables clínicas medidas, se va ver la selección de variables que hace TCGA como las más usadas. Para ello se usa la función `getClinicalNames` del paquete `curatedTGGAData` i se indica "COAD". 

```{r}
clinicalNames<-getClinicalNames("COAD")
clinicalNames
```

Si se el echa un vistazo al data frame "datos_clinicos_def" se ve que son las 18 primeras variables, columnas, por lo que eliminaremos las demás del data frame:

```{r}
datos_clinicos_def<-datos_clinicos_def[, 1:18]
datos_clinicos_def[1:2, ]
```

Como hay variables de las más usadas que no se van a usar en este estudio, se van a guardar solo aquellas que se va a usar en el análisis de supervivencia:

```{r}
datos_clinicos_def<-as.data.frame(cbind(datos_clinicos_def[, 1:6], datos_clinicos_def$gender.x, datos_clinicos_def[, 13:18]))
colnames(datos_clinicos_def)<-c("age","vital_status","days_to_death","days_to_last_follow_up","tumor_tissue_site","pathologic_stage", "gender", "radiation_therapy", "histological_type", "residual_tumor", "number_of_lymph_nodes", "race", "ethnicity")
```

Ahora se podrían seleccionar, para el análisis de supervivencia, las muestras de participantes que han muerto o que el último seguimiento fuera de más de 30 días desde el diagnóstico. [] Sin embargo, se realizará después del subtipado con iClusterBayes, eliminando las muestras que no cumplan dichos requisitos, ya que el problema de estas muestras es a nivel de datos clínicos no moleculares, por lo que incluirlas en el subtipado nos permitirá disponer de más datos para obtener mejores resultados. 

https://bmcmedgenomics.biomedcentral.com/articles/10.1186/s12920-021-00876-4
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6949097/


## 4.Filtrado de missing values:

En este papeline el filtrado solo consistirá en eliminar las muestras o variables con más de un % de missing values, ya que no son manejados por iClusterBayes. En el siguiente apartado se imputarán los missing values que no se hayan eliminado.[]

https://rdrr.io/bioc/iClusterPlus/src/R/iCluster.R
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6949097/

### 4.1. _Filtrado de muestras con determinado porcentaje de missing values en todas las ómicas._

Se filtrará aquellas muestras que tengan más de un determinado porcentaje de missing values, y aquellas con menos de dicho porcentage se imputarán en el apartado 5 de este informe. El porcentaje de missing values no tolerado se decidirá viendo los porcentajes de todas las muestras, de forma que no se eliminen de más.

https://bmcmedgenomics.biomedcentral.com/articles/10.1186/s12920-021-00876-4
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6949097/

Lo primero que se hará será crear una función `missing_values` que calcule el porcentaje de missing values por cada columna o fila. La función creada llamará a la función `apply` que aplica por fila o columna de la matriz el cálculo que se le indique. `apply` tiene tres atributos:

* x: matriz sobre la que realizarán los cálculos.
* Margin: si `apply` se ejecuta por fila se le indica un "1" y si es por columna se indica un "2".
* FUN: a `apply` hay que darle una función o un cálculo para que ejecute. 

En la función `missing_values` se llamará a `apply` a la vez que se convierte en matriz, con `as.matrix`, la base de datos de la que se quiere obtener los porcentajes de missing values. La función que aplicará `apply` sumará con `sum` todos los _NA_ de la fila o columna, a los que reconocerá con la función `is.na`. Como `is.na` debe tener un vector, "y" sobre el que ejecutarse, se debe definir una función interna en la que "y" será la fila o columna sobre la que se está ejecutando `apply`.  Una vez que la función sume los _NA_ calculará el porcentaje multiplicando por 100 y dividiendo por el número de columnas o filas dependiendo del caso. Los atributos a indicar a `missing_values` serán:

* `data`: data frame a partir de la cual se realizarán los cálculos.
* `dimention`: 1 si el porcentaje de missing values es por fila, variable. 2 si el porcentaje de missing values es por columna, muestra.
* `total`: si `dimention=1` se indicará `ncol(data)`, es decir, el número de columnas, muestras, para las que se ha medido dicha variable. si `dimention=2` se indicará `nrow(data)`, es decir, el número de filas, variables, que se han medido para dicha muestra.

https://stackoverflow.com/questions/24027605/determine-the-number-of-na-values-in-a-column
https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/apply
https://www.rdocumentation.org/packages/ursa/versions/3.9.2/topics/is.na

```{r}
missing_values<-function(data, dimention, total){
  db<-apply(as.matrix(data), dimention, function(y) sum(is.na(y))*100/total)
}
```

* *Metilación de DNA:*

Para probar la función se va a usar los datos de Metilación ya que son los únicos que tienen valores NA de los sets de datos ómicos que se van a usar. 

```{r}
tabla_mv_Met_M<-data.frame(missing_values(datos_Met_def, 2, nrow(datos_Met_def)))
colnames(tabla_mv_Met_M)<-"porcentaje"
head(tabla_mv_Met_M)
```

Para comprobar que funciona se calculará manualmente el porcentaje de _NA_ de las 4 primeras muestras por dos métodos:

* Muestra `r colnames(datos_Met_def[1])`:
```{r}
#Método con la función missing_values:
tabla_mv_Met_M[1,]
#Método 1:
#Aplicación manual de la función utilizada por apply.
sum(is.na(datos_Met_def[,1]))*100/nrow(datos_Met_def)  
#Método 2:
#Se obtiene la columna y se guarda en un vector "a", se le omiten los NA,
#posteriormente se resta el nuevo número de elementos de "a" al total de 
#valores que tenía a antes, que se corresponden con nrow(datos_Met_def). 
#A continuación se calcula el porcentaje correspondiente al número de NA 
#contados.
a<-datos_Met_def[,1]
a<-na.omit(a)
(nrow(datos_Met_def)-length(a))*100/nrow(datos_Met_def)
```

* Muestra `r colnames(datos_Met_def[2])`:
```{r}
#Método con la función missing_values:
tabla_mv_Met_M[2,]
#Método 1:
sum(is.na(datos_Met_def[,2]))*100/nrow(datos_Met_def)
#Método 2:
a<-datos_Met_def[,2]
a<-na.omit(a)
(nrow(datos_Met_def)-length(a))*100/nrow(datos_Met_def)
```

* Muestra `r colnames(datos_Met_def[3])`:
```{r}
#Método con la función missing_values:
tabla_mv_Met_M[3,]
#Método 1:
sum(is.na(datos_Met_def[,3]))*100/nrow(datos_Met_def)
#Método 2:
a<-datos_Met_def[,3]
a<-na.omit(a)
(nrow(datos_Met_def)-length(a))*100/nrow(datos_Met_def)
```

* Muestra `r colnames(datos_Met_def[4])`:
```{r}
#Método con la función missing_values:
tabla_mv_Met_M[4,]
#Método 1:
sum(is.na(datos_Met_def[,4]))*100/nrow(datos_Met_def)
#Método 2:
a<-datos_Met_def[,4]
a<-na.omit(a)
(nrow(datos_Met_def)-length(a))*100/nrow(datos_Met_def)
```

Como se puede ver en todos los casos coinciden los resultados por lo que la función `missing_values` funciona correctamente.

* *mRNA:*
Ahora se aplicará sobre los datos de mRNAseq:
```{r}
tabla_mv_mRnaseq_M<-data.frame(missing_values(datos_mRnaseq_def, 2,
                                              nrow(datos_mRnaseq_def)))
colnames(tabla_mv_mRnaseq_M)<-"porcentaje"
head(tabla_mv_mRnaseq_M)
```

Se comprueba si hay alguna muestra con missing values:
```{r}
tabla_mv_mRnaseq_M$porcentaje[tabla_mv_mRnaseq_M$porcentaje>0]
```

Ninguna muestra tiene missing values. Esto se puede deber a que son datos obtenidos de secuenciación de transcritos, donde la falta de los mismos en el alineamiento de las secuencias es que no hay expresión de dicho gen.

* *CNA:*
Se repite el mismo proceso con los datos de CNA:
```{r}
tabla_mv_CNA_M<-data.frame(missing_values(datos_CNA_def, 2, nrow(datos_CNA_def)))
colnames(tabla_mv_CNA_M)<-"porcentaje"
head(tabla_mv_CNA_M)
```

Se comprueba si hay alguna muestra con missing values:
```{r}
tabla_mv_CNA_M$porcentaje[tabla_mv_CNA_M$porcentaje>0]
```

De nuevo no hay missing values, pero esto se puede deber a que los datos de CNA Gistic ya vienen pre-procesados.

__Eliminación de muestras__

Solo se estudiará si hay que eliminar muestras en los datos de metilación ya que en los demás no había missing values. Para ello se van a graficar mediante un boxplot los porcentajes:

```{r}
boxplot(tabla_mv_Met_M, col="orange")
```

En un boxplot la raya negra de la caja representa la mediana o segundo quantil(50% de los datos), las rayas superior e inferior que dan forma a la caja son el primer(25%) y tercer quantil(75%).  Las líneas negras de fuera de la caja son el porcentaje de missing values máximo (línea superior) y mínimo (línea inferior) sin tomar en cuenta los datos atípicos.[] Éstos últimos se dibujan con circulos. En este caso solo hay un dato muy atípico, que es:

https://books.google.es/books?id=gTX3DwAAQBAJ&pg=PA127&dq=boxplot&hl=es&sa=X&ved=2ahUKEwi1woiW37_wAhUD_BQKHfslARMQ6AEwAnoECAYQAg#v=onepage&q=boxplot&f=false

```{r}
tabla_mv_Met_M$porcentaje[tabla_mv_Met_M$porcentaje>19.6]
```

Casi tiene un 20% de missing values, sin embargo, este porcentaje de missing values se podría imputar, ya que dos los papers usados como guía se eliminó las muestras con un 70% de missig values en alguna de las ómicas.[]

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6949097/
https://bmcmedgenomics.biomedcentral.com/articles/10.1186/s12920-021-00876-4

### 4.2. _Filtrado de variables con determinado porcentaje de missing values en todas las ómicas._

Se eliminarán aquellas variables con un determinado porcentaje de missing values. El porcentaje se decidirá tras observar los porcentajes de las distintas variables. Para calcularlos se usará la función `missing_values`. Pero en este caso los atributos serán `dimention=1`, ya que se quiere el porcentaje por fila, y `total=ncol(data)`.

* *Metilación de DNA:*

```{r}
tabla_mv_Met_V<-data.frame(missing_values(datos_Met_def, 1, ncol(datos_Met_def)))
colnames(tabla_mv_Met_V)<-"porcentaje"
head(tabla_mv_Met_V)
```
Como si hay missing values se graficarán con un boxplot más adelante para estudiar a partir de que porcentaje se deben eliminar las variables.

* *mRNA*

Lo mismo se hará con mRNAseq:

```{r}
tabla_mv_mRnaseq_V<-data.frame(missing_values(datos_mRnaseq_def, 1,
                                              ncol(datos_mRnaseq_def)))
colnames(tabla_mv_mRnaseq_V)<-"porcentaje"
head(tabla_mv_mRnaseq_V)
```

```{r}
tabla_mv_mRnaseq_V$porcentaje[tabla_mv_mRnaseq_V$porcentaje>0]
```

De nuevo no hay missing values.

* *CNA*:

```{r}
tabla_mv_CNA_V<-data.frame(missing_values(datos_CNA_def, 1, ncol(datos_CNA_def)))
colnames(tabla_mv_CNA_V)<-"porcentaje"
head(tabla_mv_CNA_V)
```

Se comprueba si hay missing values:
```{r}
tabla_mv_CNA_M$porcentaje[tabla_mv_CNA_M$porcentaje>0]
```

De nuevo no hay missing values.

__Eliminación de variables__

Solo se estudiará si hay que eliminar variables en los datos de metilación ya que en los demás no había missing values. Para ello se van a graficar mediante un boxplot los porcentajes:

```{r}
boxplot(tabla_mv_Met_V, col="blue")
```
Se van a eliminar únicamente las que tengan un 70% de missing values, ya que es el porcentaje usado en los papers en los que se basa este papeline. Sin embargo, los casos con más de 70% de missing values, en realidad tienen 100%.

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6949097/
https://bmcmedgenomics.biomedcentral.com/articles/10.1186/s12920-021-00876-4

Para hacerlo primero se va a combinar el data frame datos_Met_def con la tabla_mv_Met_V, que como la tabla se obtuvo a partir del data frame tienen el mismo orden de filas.

```{r}
datos_Met_def_se<-as.data.frame(cbind(datos_Met_def, tabla_mv_Met_V))
datos_Met_def_se[1:5, 271:273]
```

Ahora se eliminará las filas con más de un 70% en porcentaje.

```{r}
datos_Met_def_se<-datos_Met_def_se[datos_Met_def_se$porcentaje<70,]
datos_Met_def_se[1:5, 271:273]
```
El número de filas eliminadas ha sido de `r nrow(datos_Met_def)-nrow(datos_Met_def_se)` de las cuales, como se ve en el box plot, el 100% tenían 100% de missing values.

A continuación redefinimos el data frame "datos_Met_def" eliminando de "datos_Met_def_se" la columna porcentajes.

```{r}
datos_Met_def<-datos_Met_def_se[, 1:272]
datos_Met_def[1:5, 1:3]
```

Como se puede ver, comparando con la primera tabla de "datos_Met_def_se", se han eliminado los que tienen 100% de missing values.

Finalmente se va a ordenar las bases de datos para que las columnas estén en el mismo orden.

iManual
https://www.bioconductor.org/packages/release/bioc/vignettes/iClusterPlus/inst/doc/iManual.pdf

```{r}
#datos_CNA_def<-datos_CNA_def[order(colnames(datos_CNA_def)),]
```

Por último se ordenará las columnas de mRNA con el mismo orden que las de CNA y Met:

```{r}
names<-colnames(datos_mRnaseq_def)
temp<-colnames(datos_CNA_def)
v<-vector()
for (i in 1:length(temp)){
  for (j in 1:length(names)){
    if(temp[i]==names[j]){
      v<-c(v, j)
    }
  }
}
```

```{r}
a<-data.frame()
p<-0
for (i in v){
  if(p>0){
    a<-cbind(a,datos_mRnaseq_def[, i])
  }
  if(p==0){
    a<-datos_mRnaseq_def[, i]
    p<-p+1
  }
} 
```

```{r}
a[1:5,1:5]
```

Si se visualiza el data frame "datos_mRnaseq_def" se ve que las 4 primeras muestras que aparecen en "datos_CNA_def" aparecen a partir de la columna 6 de "datos_mRnaseq_def", por lo que vamos a comprobar si se han guardado las muestras en el orden correcto.

```{r}
datos_mRnaseq_def[1:5, 6:9]
```
La siguiente muestra que aparece en "datos_CNA_def" aparece en la columna 42 de "datos_mRnaseq_def":
```{r}
test<-as.data.frame(datos_mRnaseq_def[1:5, 42])
colnames(test)<-colnames(datos_mRnaseq_def[42])
test
```
Se comprueba que los datos coinciden.

A continuación guardamos nuestro nuevo data frame a bajo el nombre de "datos_mRnaseq_def" y les damos nombre a las columnas:
```{r}
names<-rownames(datos_mRnaseq_def)
datos_mRnaseq_def<-as.data.frame(a)
rownames(datos_mRnaseq_def)<-names
colnames(datos_mRnaseq_def)<-colnames(datos_CNA_def)

```


A continuación se comprueba que tienen el mismo orden:


