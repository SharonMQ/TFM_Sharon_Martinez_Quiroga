---
title: "Trabajo de Fin de Máster: Workflow 1 con iClusterBayes como método de integración de datos multiómicos"
date: "1/5/2021"
output: pdf_document
bibliography: Workflow1.bib
csl: springer-vancouver-brackets.csl
---



**_Máster en Bioinformática y Bioestadística_** 

**Área del trabajo:_2_**

**Título del Trabajo: _Detección de biomarcadores de prognosis en Colon adenocarcinoma mediante la integración de datos ómicos con varios métodos disponibles_**

**Nombre del autor/a:_Sharon Martínez Quiroga_**

**Nombre del consultor/a:_Jaume Sastre Tomàs_**

**Nombre del PRA:_Marc Maceira Duch_**




## Indice:

1. __Preparación del entorno de trabajo.__
  * 1.1. _Preparación del entorno._
  * 1.2. _Carga de paquetes a utilizar._
2. __Descarga de datos.__
3. __Selección de muestras__
  * 3.1. _Selección de muestras patológicas._
  * 3.2. _Selección de muestras que tengan datos pada las tres ómicas a integrar._
  * 3.3. _Selección de muestras con seguimiento mayor de 30 días._
4. __Filtrado de muestras__
  * 4.1. _Filtrado de muestras con x% de missing values en todas las ómicas._
  * 4.2. _Filtrado de variables con un x% de missing values._
5. __Imputación de missing values.__
6. __Transformación de datos.__
7. __Control de calidad.__
8. __Normalización de datos.__
9. __Control de calidad.__
10. __Integración de datos.__
11. __Visualización de resultados.__
12. __Integración de redes.__
13. __Análisis de prognosis.__
14. __Modelo de Prognosis.__
15. __Evaluación del modelo de prognosis.__

## Preparación del entorno de trabajo:

### 1.1. Preparación del entorno:

Lo primero que hacemos es definir en el chunk el atributo cache=TRUE, para que R guarde los resultados de los chunks y solo repita la ejecución de un chunk, y de los otros chunks que se vean afectados por dicho cambio cuando se cambie el código en el chunk.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NULL, cache = TRUE)
```

Ahora definimos nuestro directorio:
```{r}
setwd("/media/home/ESD-USB/UOC/6to cuatrimestre/TFM/Workflows/Workflow iClusterBayes")
```

### 1.2. Carga de paquetes a utilizar.

Ahora vamos a cargar los paquetes que vamos a utilizar y que explicaremos según se vayan requiriendo:

```{r message=FALSE, warning=FALSE}
library(curatedTCGAData)
library(readr)
library(TCGAutils)
library(MultiAssayExperiment)
```

## 2.Descarga de datos.

### Descarga de datos de CNA y Metilación de DNA:

Para saber que archivos que queremos descargar será necesario ver que archivos hay disponibles para Adenocarcinoma de colon (*COAD*). Esto se realizará con la función `curatedTCGAData` del paquete con el mismo nombre [@curatedTCGAData; @mancuratedTCGAData; @paqcuratedTCGAData]. Para ello se definirán los atributos:

* _`diseaseCode`_: código de la enfermedad de estudio, en este caso COAD.
* _`assays`_: tipos de datos de los que se quiere información. Se indicará "*" para ver todos los datos disponibles.
* _`dry.run`_: Se indicará TRUE porque solo queremos visualizar un resumen de los datos. Si se indicara FALSE se descargarían los paquetes indicados.$^{1,2}$

```{r message=FALSE, warning=FALSE}
curatedTCGAData(diseaseCode = "COAD", assays = "*", dry.run = TRUE)
```

Ahora vamos a descargar los datos con la misma función, pero indicando los siguientes atributos:

* _`diseaseCode`_: COAD.
* _`assays`_: solo indicaremos GISTIC_AllByGene porque el paquete descarga muy pocos datos de las demás ómicas que queremos.
* _`dry.run`_: Se indicará TRUE porque solo queremos visualizar un resumen de los datos. Si se indicara FALSE se descargarían los paquetes indicados.$^{1,2}$

Solo se descargargarán los archivos "GISTIC_AllByGene", "Methylation_methyl450", "miRNASeqGene" porque los archivo de "RNASeqGene" y "RNASeq2GeneNorm" no contienen los datos de todas las muestras disponibles en la web de Firehouse, por lo que los datos de RNAseq se descargarán manualmente. 

```{r message=FALSE, warning=FALSE}
datos_COAD<-curatedTCGAData::curatedTCGAData(diseaseCode = "COAD", 
assays = c("GISTIC_AllByGene", "Methylation_methyl450"),
dry.run = FALSE)
```

Los datos que se van a utilizar y que se han descargado son:

* GISTIC_AllByGene: Esta base de datos contiene los CNA por gen en scores. Para obtener los scores, GISTIC primero calcula las unidades de CNA-2 por CNA medido(marker level), 2 porque el ser humano tiene mínimo dos copias de cada gen o región, una por alelo o cromosoma homólogo. Como tenemos valores de CNA, el marker level nunca podrá tener valor 0, es decir, siempre habrá amplificación o deleción de copias. Los números positivos indican amplificación y los negativos deleción. A partir de estos valores GISTIC obtiene los scores que miden el nivel de CNAs por gen (gene level). El método que usa para obtener los scores se denomina método extremo, porque el score es el mayor marker level de cada gen para cada muestra, es decir, elige de entre las unidades de CNA-2, calculadas antes, el CNA que de entre todos los CNA presentes en dicho gen, tenga mayor amplificación, o bien, el menor valor de deleción. 

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5302158/

* Methylation_methyl450: Contiene los row counts para cada probe del array 

Estos datos se han descargado en un objeto MultiAssayExperiment usado por algunas herramientas de integración como por ejemplo MOFA. Estos objetos permiten almacenar varios experimentos con distinto número de filas(variables). Su estructura es la siguiente:

* `ExperimentList`: Es una lista que contiene los distintos experimentos(Assays) que se han descargado. Los datos de los experimentos, guardados en la lista, están almacenados en un data frames por experimento, donde las columnas son las muestras u observaciones, y las filas las variables medidas para cada expreimento. Em esta ÈxperimentList` se encuentra:

```{r}
datos_COAD@ExperimentList
```

* `colData`: contiene los datos clínicos de cada muestra, es un data frame con una fila por muestra y una columna por variable cínica. En este caso:

```{r}
datos_COAD@colData[1:5,1:5]
```

* `sampleMap`: Contiene una tabla con los códigos de referencia de las muestras que hay por cada experimento.

```{r}
 datos_COAD@sampleMap
```

https://bioconductor.org/packages/release/bioc/vignettes/MultiAssayExperiment/inst/doc/MultiAssayExperiment.html#a-brief-description
http://bioconductor.org/packages/release/bioc/vignettes/MOFA/inst/doc/MOFA_example_scMT.html

En iClusterBayes se usan data frames por lo que más adelante será necesario extraer los datos del objeto MultyAssayExperiment.

https://bioconductor.org/packages/release/bioc/vignettes/iClusterPlus/inst/doc/iManual.pdf
### Descarga de mRNAseq:

Se observó que hay menos datos de mRNAseq en disponibles en el paquete `curatedTCGAData` que en la web de Firehose, por tanto, se descargó manualmente el archivo y se guardó en el directorio de este papeline. Posteriormente se cargó usando la función `read_delim` del paquete `readr`. Como se encuentra en el mismo directorio del papeline no fue necesario indicar la ruta. Los atributos indicados fueron:

* `file`: nombre del documento o ruta. 
* `delim`: tipo de separación entre los valores, en este caso, tab `\t`

```{r message=FALSE, warning=FALSE}
datos_mRnaseq<- 
  read_delim("COAD.rnaseqv2__illuminahiseq_rnaseqv2__unc_edu__Level_3__RSEM_genes__data.data.txt", 
    "\t")
datos_mRnaseq[1:5,1:5]
```

Como se puede ver hay varias variables por cada muestra, lo que hace esencial que se procese el data frame para quedarse solo con la columna de raw_counts de cada muestra y la columna "Hybridization REF" con las anotaciones de los genes_ID. Para elegir solo las columnas que queremos se usará la función `select` del paquete `dplyr` que permite seleccionar las columnas que terminen en determinados caracteres mediante el atributo `ends_with` o bien, seleccionar las que no terminen en determinados caracteres si se le añade un operador `!` delante de `ends_with`. Se seleccionaran aquellas columnas que no terminen en "_1" y "_2".

https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/select

```{r}
datos_mRnaseq<-dplyr::select(datos_mRnaseq, !ends_with("_1"))
datos_mRnaseq<-dplyr::select(datos_mRnaseq, !ends_with("_2"))
datos_mRnaseq[1:5, 1:5]
```
Una vez eliminadas las columnas que no se van a usar, será necesario eliminar la fila 1 para que al usar los datos dicha fila no genere errores.

```{r}
datos_mRnaseq<-datos_mRnaseq[2:20532,1:329]
datos_mRnaseq[1:5, 1:5]
```

En este archivo vienen ya mapeados los transcritos secuenciados con RNAseq, por lo que se tiene los row counts para cada gen. Además, en la primera columna está anotado el "Gene Symbol" o Símbolo oficial del gen y el "gen_ID" o identificador del gen de Entrez Gene, separados por el caracter "|".

https://bioconductor.org/packages/release/data/annotation/manuals/org.Hs.eg.db/man/org.Hs.eg.db.pdf

```{r}
datos_mRnaseq[28:32, 1:5]
```

Se ha observado en búsquedas en Gene de NCBI que hay genes en los que no está anotado el Gene Symbol, pero que desde que se hizo la versión de este archivo ya se han anotado, o bien otros han cambiado de Gene Symbol. Por ello, cuando se haya realizado la integración y se haya obtenido los genes que pueden ser posibles biomarcadores, se les eliminará los Gene Symbol y se volverá a realizar la anotación de los mismos a partir de los códigos Entrez_ID. Además, se ha observado que algunos códigos Entrez_ID están descatalogados y se les ha asignado un nuevo código Entrez_ID que habrá que anotar manualmente cada vez que en la anotación ocurra un error. Por esta razón se dejará este paso para más adelante, ya que solo se anotarán los genes diferencialmente expresados que sean importantes tras la integración.

A continuación, se convertirá los gene_ID en los nombres de las filas y eliminaremos la primera columna de datos_mRnaseq, para que no de problemas en el resto de pasos de este análisis, ya que se tomaría la primera columna como una muestra con datos de counts. 

Para guardar los datos de gene_ID como vector primero es necesario convertir la
columna extraida del data frame en una matriz.
```{r}
row_n<-as.vector(as.matrix(datos_mRnaseq[, 1]))
head(row_n)
```

Ahora se guarda datos_mRnaseq sin la primera columna.
```{r}
datos_mRnaseq<-datos_mRnaseq[,2:329]
datos_mRnaseq[1:5,1:2]
```

Finalmente, se da nombre a las filas, para ello primero se tiene que hacer es transformar datos_mRnaseq en un data frame normal, ya que de firehose se descarga en formato tibble, que es un tipo especial de data frame usado en ciencia de datos que no acepta que las filas tengan nombre, y que no es el usado por iClusterBayes.

https://tibble.tidyverse.org/
```{r}
datos_mRnaseq<-as.data.frame(datos_mRnaseq)
rownames(datos_mRnaseq)<-row_n
datos_mRnaseq[1:5,1:2]
```

Para iClusterBayes será necesario trasponer este data frame, para que las muestras sean las filas y los genes las columnas, pero se realizará después de la normalización de datos.

https://bioconductor.org/packages/release/bioc/vignettes/iClusterPlus/inst/doc/iManual.pdf

## 3.Selección de muestras

### 3.1.Selección de muestras patológicas.

Para seleccionar las muestras patológicas vamos a usar dos métodos distintos según si los datos están en el objeto MultiAssayExperiment o en el data frame.

* *Selección de muestras patológicas guardadas en el objeto MultiAssayExperiment(datos_COAD)*: 

Se utilizará el paquete `TCGAutils` para hacer la selección. Lo primero que se realizará será ver los tipos de muestras que hay disponibles en TCGA y su código correspondiente dentro de los códigos de referencia. Para ello se descargará el data frame "sampleTypes" que contiene esta información disponible en el paquete. 

https://bioconductor.org/packages/release/bioc/vignettes/TCGAutils/inst/doc/TCGAutils.html#mergecoldata-expanding-the-coldata-of-a-multiassayexperiment

```{r}
data("sampleTypes")
sampleTypes
```

Ahora se verá los tipos de muestras que hay en el objeto "datos_COAD" por experimento, se usará la función `sampleTables` del mismo paquete.

```{r}
sampleTables(datos_COAD)
```
Como se ve la mayor parte de las muestras tiene el código "01" por lo que pertenecen al Tumor Primario. También hay alguna muestra de tumor recidivante "02" y de metastasico "06", pero no se van a incluir en el análisis porque, por un lado, no hay un número de muestras significativo de estos tipos, así que incluirlas solo añadiría impresición al análisis. Y por otro lado, estos tipos de muestras no aparecen en todas las ómicas.

Además, como buscamos marcadores de prognosis descartaremos las muestras de tejido normal adyacente al tumor, "11".

Para seleccionar las muestras "01" se usará la función `splitAssays` del paquete `TCGAutils`.

```{r message=FALSE, warning=FALSE}
datos_COAD_se<- splitAssays(datos_COAD, "01")
```

Se comprueba que se han guardado solo los "01":
```{r}
sampleTables(datos_COAD_se)
```
* *Selección de muestras patológicas guardadas en el data frame(datos_mRNAseq)*: 

Para obtener las muestras patológicas lo primero que se debe hacer es guardar en un vector "names" los códigos de referencia, y posteriormente extraer de cada código el fragmento que nos indica el tipo de muestra. Para ello se usa la función `str_sub` del paquete `stringr`, y se indica que los caracteres que nos interesan empiezan en la posición 14 y terminan en la 15, por tanto, son los dos caracteres de la región "Sample" del código de referencia. 

```{r}
names<-as.vector(colnames(datos_mRnaseq))
names<-stringr::str_sub(names, start =14 , end = 15)
names[7:10]
```

Se observa, en las muestras de las posiciones 7-10 del vector, que hemos extraido las regiones de interes, se eligieron estas posiciones porque se ven dos posibles códigos.

```{r}
datos_mRnaseq[1:5, 7:10]
```

Se comprueba que los códigos extraidos son los que se desea. Ver _Anexo: Código TCGA_ de la memoria. 

A continuación creamos un vector "TP" en el que se guarda TRUE cada vez que en "names" aparece un código "01" o Tumor Primario.
```{r}
TP<-as.vector(names=="01")
TP[7:11]
table(TP)
```

Se observa que la mayoría de los datos son de Tumor Primario.

A continuación, se crea una función `selec_col` en la que se recorre la posición "i" de cada elemento del vector "boolean_vector". En dicho vector aparece TRUE cada vez que en esa posición hay una de las muestras que queremos. Todas las muestras se han extraido del data frame "data" en ese orden. Finalmente, cada vez que hay un TRUE se añadirá la columna del data frame original "data" que esté en la misma posición a un nuevo data frame, obteniendo como resultado de la función un data frame con las muestras deseadas.

```{r}
selec_col<-function(data, boolean_vector){
  db<-data.frame()
  p<-0
  for (i in 1:length(boolean_vector)){
    if (boolean_vector[i]==TRUE){
      if(i==1){
        db<-data[,i]
      }
      if(i>1){
        if(p==1){
          db<-cbind(db, data[,i])
        }
        if(p==0){
          db<-data[,i]
          p<-1
        }
      }
    }
  }
  return(db)
}
```

Se usa la función `selec_col` definiendo:

* `data`: datos_mRnaseq.
* `boolean_vector`: TP.

Y se comprueba los resultados:
```{r}
datos_mRnaseq_se<-as.data.frame(selec_col(datos_mRnaseq, TP))
datos_mRnaseq_se[1:5, 7:11]
```
Se comprueba que los datos coinciden con los de las muestras con "01" en la cuarta región del código.
```{r}
datos_mRnaseq[1:5, 7:11]
```

Ahora se seleccionarán los nombres de las columnas y se renombrarán las columnas y filas. Se crea una función igual que la anterior, llamada `selec_col_n`, pero que en vez de introducirle un data frame con las columnas a seleccionar, se le introduce un vector con los elementos a guardar `col_n_data`. Se guardarán los elementos de `col_n_data` que aparezcan en las posiciones TRUE del `boolean_vector`. El resultado será un vector con los nombres de las muestras con tumor primario seleccionadas.

```{r}
selec_col_n<-function(col_n_data, boolean_vector){
  v<-vector()
  p<-0
  for (i in 1:length(boolean_vector)){
    if (boolean_vector[i]==TRUE){
      if(i==1){
        v<-col_n_data[i]
      }
      if(i>1){
        if(p==1){
          v<-c(v, col_n_data[i])
        }
        if(p==0){
          v<-col_n_data[i]
          p<-1
        }
      }
    }
  }
  return(v)
}
```
Se usa la función `selec_col` definiendo:

* `col_n_data`:colnames(datos_mRnaseq) .
* `boolean_vector`: TP.

```{r}
col_n<-selec_col_n(as.vector(colnames(datos_mRnaseq)),TP )
col_n[7:11]
```

Y se comprueba los resultados viendo que se han eliminado los "11":
```{r}
colnames(datos_mRnaseq[7:12])
```

Finalmente damos nombre a las filas y columnas:

```{r}
colnames(datos_mRnaseq_se)<-col_n
rownames(datos_mRnaseq_se)<-rownames(datos_mRnaseq)
datos_mRnaseq_se[1:5,6:9]
```


### 3.2. Selección de muestras que tengan datos para las tres ómicas a integrar.

* *Muestras con datos de CNA y Metilación de DNA:*
Ahora se seleccionarán aquellas observaciones que tengan datos en todas las ómicas. Lo primero es ver las observaciones que tienen datos de CNA y Metilación, ya que se encuentran en un objeto MultiAssayExperiment, y existe una función `MatchedAssayExperiment` del paquete `MultiAssayExperiment` que selecciona las observaciones presentes en todos los assays del objeto. 

```{r message=FALSE, warning=FALSE}
datos_COAD_se<-MatchedAssayExperiment(datos_COAD_se)
datos_COAD_se@ExperimentList@listData
```

Como se observa, hay el mismo número de columnas en ambos assays, en CNA = `r ncol(datos_COAD_se@ExperimentList@listData$'01_COAD_GISTIC_AllByGene-20160128')` y en Met=`r `ncol(datos_COAD_se@ExperimentList@listData$'01_COAD_Methylation_methyl450-20160128')`

Más adelante se utilizarán estos datos como data frame, por lo que se va a proceder a guardar los datos del objeto MultiAssayExperiment en un directorio llamado "datos". Para ello se usará la función `exportClass` del paquete `MultiAssayExperiment`.

https://bioconductor.org/packages/devel/bioc/vignettes/MultiAssayExperiment/inst/doc/QuickStartMultiAssay.html

```{r}
dir.create("Datos")
exportClass(datos_COAD_se, dir = "Datos", fmt = "csv", ext = ".csv")
```

Ahora se cargarán los data frames guardados para poder usarlos en los pasos siguientes.

Lo primero que se hará será cargar los datos de CNA y de Metilación siguiendo el mismo proceso. Para ello primero se cargará el archivo.csv con la función `read_csv` del paquete `readr`. Como se cargan en formato tribble se convertirán a data frame con `as.data.frame`. La primera columna son los nombres de las filas, genes, por lo que se da los valores de la primera columna a las filas con la función `rownames`, y a continuación se elimina la primera columna.
```{r message=FALSE, warning=FALSE}
datos_CNA<-as.data.frame(read_csv("Datos/datos_COAD_se_01_COAD_GISTIC_AllByGene-20160128.csv"))
rownames(datos_CNA)<-datos_CNA$X1
datos_CNA<-datos_CNA[, -1]
datos_CNA[1:5, 1:2]
```

A continuación se acortarán los nombres de las muestras, dejando solo la parte del código común a todas las muestras de un mismo participante, inclusive se eliminará el 01 de tumor primario. Esto se hará con la función `str_sub` del paquete `stringr`.

```{r message=FALSE, warning=FALSE}
temp<-colnames(datos_CNA)
colnames(datos_CNA)<-stringr::str_sub(temp, start=1, end=12)
datos_CNA[1:5, 1:2]
```

Se comprueba que los códigos y sus datos coinciden, y por tanto se ha realizado correctamente el cambio de nombre de las columnas.

Se repite todo el proceso con los datos de metilación:
```{r message=FALSE, warning=FALSE}
datos_Met<-as.data.frame(read_csv("Datos/datos_COAD_se_01_COAD_Methylation_methyl450-20160128.csv"))
rownames(datos_Met)<-datos_Met$X1
datos_Met<-datos_Met[, -1]
datos_Met[1:5, 1:2]
```

Se renombra las muestras:
```{r message=FALSE, warning=FALSE}
temp<-colnames(datos_Met)
colnames(datos_Met)<-stringr::str_sub(temp, start=1, end=12)
datos_Met[1:5, 1:2]
```

Finalmente se cargan los datos clínicos. Se define los nombres de las filas como los códigos de referencia por paciente, patientID, que es la segunda columna que aparece, y que es idéntica a la primera. Por esta razón, despues de dar nombre a las filas se eliminan las dos primeras columnas.

```{r message=FALSE, warning=FALSE}
datos_clinicos<-as.data.frame(read_csv("Datos/datos_COAD_se_colData.csv"))
rownames(datos_clinicos)<-datos_clinicos$patientID
datos_clinicos<-datos_clinicos[, 3:2616]
datos_clinicos[1:5, 1:5]
```

* *Muestras con datos de CNA, Metilación de DNA y mRNA:*

__A continuación, se selecciona los datos de mRNAseq que haya para estas muestras con CNA y Metilación, y al final se eliminará las muestras de CNA y Met para las que no haya datos de mRNAseq.__

__La primera parte es seleccionar las muestras de mRNAseq que tienen datos de CNA y de Metilación__, para ello se va a juntar en el mismo vector los códigos de las muestras de mRNA y los de las muestras en CNA, posteriormente se factorizará el vector, y se elaborará una tabla con la frecuencia de los niveles(muestras). Se seleccionará aquellos niveles que tengan una frecuencia de 2 (1 por mRNAseq y 1 por CNA). No se une también las muestras de Met porque coinciden con las de CNA, añadirlos sería un paso innecesario.

Para hacer este proceso es necesario que coincidan los nombres de las muestras, así que se debe acortar los códigos de referencia de los datos de mRNAseq, al igual que se hizo con los demás  sets de datos. Primero se mostrará el data frame inicial para poder posteriormente comprobar que el cambio se realizó sin generar errores.
```{r}
datos_mRnaseq_se[1:5,1:3]
```

A continuación renombramos las muestras y comprobamos, comparando con el resultado anterior, que se han renombrado las muestras sin generar errores en la correspondencia datos y código.
```{r}
temp<-colnames(datos_mRnaseq_se)
colnames(datos_mRnaseq_se)<-stringr::str_sub(temp, start=1, end=12)
datos_mRnaseq_se[1:5,1:3]
```

PAra ver que muestras están en las tres ómicas se guarda en el mismo vector el nombre de las muestras de CNA y Met, y los nombres de mRNAseq.

```{r}
muestras<-c(colnames(datos_CNA), colnames(datos_mRnaseq_se))
length(muestras)==length(colnames(datos_CNA))+length(colnames(datos_mRnaseq_se))
```

Observamos que se han guardado todos los códigos de las ómicas a estudiar(recordemos que se omitió Met para evitar redundancia), ya que el vector de los códigos conjuntos es igual a la suma de los códigos de cada ómica. 
```{r}
muestras_se<-as.data.frame(table(factor(muestras)))
head(muestras_se)
```
A continuación se selecciona aquellas muestras que aparezcan 2 veces, y como hay una por fila del data frame, contamos cuantas muestras están en datos CNA y mRNAseq mediante `nrow`. 
```{r}
muestras_se<-muestras_se[muestras_se$Freq==2,]
nrow(muestras_se)
head(muestras_se)
```
A continuación se define una función, `selec_omicas` que recorre cada código de cada muestra de la base de datos original, datos_mRnaseq_se, y los compara con cada código de aquellas muestras que se quiere seleccionar, que son las de frecuencia 2. Por cada muestra de la base de datos original se guardará un boolean en un vector que se ha denominado `TP`. El boolean sera TRUE si la muestra de esa posición coincide con alguna de las muestras deseadas, y será FALSE si no hay ninguna coincidencia.

```{r}

selec_omicas<-function(datos, datos_selec){
  boolean_vector<-vector()
  for (i in 1:length(datos)){
    t<-0
    for(j in 1:length(datos_selec)){
      if (datos[i]==datos_selec[j]){
        t<-1
      }
    }
    if (t==1){
       boolean_vector<-c(boolean_vector, TRUE)
    }
    if (t==0){
       boolean_vector<-c(boolean_vector, FALSE)
    }
  }
  return(boolean_vector)
}

```

A continuación se llama a la función definiendo:

*`data`: códigos de las muestras en datos_mRnaseq_se, es decir, nombre de las columnas.

*`datos_selec`: códigos de las muestras presentes en datos_mRnaseq_se y datos_CNA.

```{r}
names<-colnames(datos_mRnaseq_se)
temp<-as.vector(muestras_se$Var1)
muestras_mRNA<-selec_omicas(names, temp)
head(muestras_mRNA)
```
Se genera un vector de booleans que indica en cada posición si la correspondiente columna en datos_mRnaseq_se está también presente en datos_CNA. A continuación, se llama a las funciones `selec_col` y `selec_col_n` para seleccionar las columnas de datos_mRnaseq_se que tengan un TRUE en el vector de booleans generado con la función `selec_omicas` guardado bajo el nombre "muestras mRNA". 

```{r}
datos_mRnaseq_def<-as.data.frame(selec_col(datos_mRnaseq_se, muestras_mRNA))
colnames(datos_mRnaseq_def)<-selec_col_n(colnames(datos_mRnaseq_se), muestras_mRNA)
row.names(datos_mRnaseq_def)<-row.names(datos_mRnaseq_se)
ncol(datos_mRnaseq_def)==nrow(muestras_se)
```

Se ve el data frame de datos mRNA:
```{r}
datos_mRnaseq_def[1:5,1:2]
```

Se observa que el resultado final es un data frame con datos de mRNAseq con el mismo número de columnas, muestras, que el número de filas, muestras, cuyo código estaba en datos_mRNAseq_se y en datos_CNA.

__La segunda parte de este proceso consiste en eliminar de los data frames de CNA y Met las muestras que no tengan datos de mRNA.__ Para ello primero obtendremos, con la función `selec_omicas`, un vector de booleans que indique que muestras del data frame "datos_CNA" o bien "datos_Met", también están en el data frame "datos_mRnaseq_def". Habrá un TRUE en cada posición de "datos_CNA" o "datos_Met" en la que ocurra una coincidencia con alguna muestra de datos_mRNAseq_def. Después, con la función `selec_col` se guardará aquellas columnas de "datos_CNA" o "datos_Met" de muestras que tengan un TRUE en el vector de booleans. Finalmente dará el nombre de cada muestra a cada columna del nuevo data frame con la función `selec_col_n`. 

  * Para CNA:
```{r}
names<-colnames(datos_CNA)
temp<-colnames(datos_mRnaseq_def)
muestras_CNA<-selec_omicas(names, temp)
head(muestras_CNA)
```

```{r}
datos_CNA_def<-as.data.frame(selec_col(datos_CNA, muestras_CNA))
colnames(datos_CNA_def)<-selec_col_n(colnames(datos_CNA), muestras_CNA)
row.names(datos_CNA_def)<-row.names(datos_CNA)
datos_CNA_def[1:5,1:2]
```

* Para Metilación:

```{r}
names<-colnames(datos_Met)
temp<-colnames(datos_mRnaseq_def)
muestras_Met<-selec_omicas(names, temp)
head(muestras_Met)
```

```{r}
datos_Met_def<-as.data.frame(selec_col(datos_Met, muestras_Met))
colnames(datos_Met_def)<-selec_col_n(colnames(datos_Met), muestras_Met)
row.names(datos_Met_def)<-row.names(datos_Met)
datos_Met_def[1:5,1:2]
```


Finalmente se hace con los datos clínicos:

```{r}
datos_clinicos<-t(datos_clinicos)
names<-colnames(datos_clinicos)
temp<-colnames(datos_mRnaseq_def)
muestras_clinicas<-selec_omicas(names, temp)
head(muestras_clinicas)
```

```{r}
datos_clinicos_def<-as.data.frame(selec_col(datos_clinicos, muestras_clinicas))
colnames(datos_clinicos_def)<-selec_col_n(colnames(datos_clinicos), muestras_clinicas)
row.names(datos_clinicos_def)<-row.names(datos_clinicos)
datos_clinicos_def<-as.data.frame(t(datos_clinicos_def))
datos_clinicos_def[1:5,1:5]
```

### 3.3. _Selección de muestras con seguimiento mayor de 30 días._

Como hay tantas variables clínicas medidas, se va ver la selección de variables que hace TCGA como las más importantes. Para ello se usa la función `getClinicalNames` del paquete `curatedTGGAData` i se indica "COAD". 

```{r}
clinicalNames<-getClinicalNames("COAD")
```




## 4.Filtrado de muestras





### 4.1. _Filtrado de muestras con x% de missing values en todas las ómicas._
### 4.2. _Filtrado de variables con un x% de missing values._









